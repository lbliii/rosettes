{"url":"/docs/highlighting/basic-usage/","title":"Basic Usage","description":"Using highlight() and tokenize() for syntax highlighting","plain_text":"Basic Usage The two primary functions for syntax highlighting. highlight() Generate HTML with syntax-highlighted code. from rosettes import highlight html = highlight(&quot;def hello(): pass&quot;, &quot;python&quot;) Parameters Parameter Type Default Description code str required Source code to highlight language str required Language name or alias hl_lines set[int] None 1-based line numbers to highlight show_linenos bool False Include line numbers css_class str None Container CSS class css_class_style str &quot;semantic&quot; &quot;semantic&quot; or &quot;pygments&quot; Language Aliases Languages accept multiple aliases: # These are equivalent highlight(code, &quot;python&quot;) highlight(code, &quot;py&quot;) highlight(code, &quot;python3&quot;) # JavaScript aliases highlight(code, &quot;javascript&quot;) highlight(code, &quot;js&quot;) CSS Class Styles Semantic (default) — readable class names: html = highlight(code, &quot;python&quot;) # css_class_style=&quot;semantic&quot; # &lt;span class=&quot;syntax-keyword&quot;&gt;def&lt;/span&gt; # &lt;span class=&quot;syntax-function&quot;&gt;hello&lt;/span&gt; Pygments — compatible with Pygments themes: html = highlight(code, &quot;python&quot;, css_class_style=&quot;pygments&quot;) # &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; # &lt;span class=&quot;nf&quot;&gt;hello&lt;/span&gt; Container Class The output is wrapped in a container &lt;div&gt;: # Default: &quot;rosettes&quot; for semantic, &quot;highlight&quot; for pygments html = highlight(code, &quot;python&quot;) # &lt;div class=&quot;rosettes&quot; data-language=&quot;python&quot;&gt;... html = highlight(code, &quot;python&quot;, css_class_style=&quot;pygments&quot;) # &lt;div class=&quot;highlight&quot; data-language=&quot;python&quot;&gt;... # Custom class html = highlight(code, &quot;python&quot;, css_class=&quot;my-code&quot;) # &lt;div class=&quot;my-code&quot; data-language=&quot;python&quot;&gt;... tokenize() Get raw tokens without formatting. Useful for custom output formats or analysis. from rosettes import tokenize tokens = tokenize(&quot;x = 42&quot;, &quot;python&quot;) for token in tokens: print(f&quot;{token.type.name}: {token.value!r}&quot;) Output: NAME: 'x' WHITESPACE: ' ' OPERATOR: '=' WHITESPACE: ' ' NUMBER_INTEGER: '42' Token Structure Each token is a NamedTuple with: Attribute Type Description type TokenType Semantic token type value str The actual text line int 1-based line number column int 1-based column number token = tokens[0] print(token.type) # TokenType.NAME print(token.value) # &#x27;x&#x27; print(token.line) # 1 print(token.column) # 1 Use Cases Custom formatters: Build terminal, LaTeX, or other output formats Analysis: Count tokens, find patterns, compute metrics Testing: Verify lexer behavior Transformations: Modify code based on token structure Error Handling Both functions raise LookupError for unsupported languages: from rosettes import highlight, supports_language # Check before highlighting if supports_language(&quot;python&quot;): html = highlight(code, &quot;python&quot;) # Or handle the exception try: html = highlight(code, &quot;unknown&quot;) except LookupError as e: print(f&quot;Unsupported language: {e}&quot;) Next Steps Parallel Processing — highlight_many() for multiple blocks Line Highlighting — Highlight specific lines CSS Classes — Style your output","excerpt":"Basic Usage The two primary functions for syntax highlighting. highlight() Generate HTML with syntax-highlighted code. from rosettes import highlight html = highlight(\"def hello(): pass\", \"python\")...","metadata":{"title":"Basic Usage","description":"Using highlight() and tokenize() for syntax highlighting","draft":false,"weight":10,"lang":"en","type":"doc","tags":["highlighting","api"],"keywords":["highlight","tokenize","basic usage"],"icon":"code","variant":"standard"},"section":"highlighting","tags":["highlighting","api"],"word_count":357,"reading_time":2,"graph":{"nodes":[{"id":"2091112251267089877","label":"Reference","url":"/docs/reference/","type":"regular","tags":["reference","api"],"incoming_refs":8,"outgoing_refs":5,"connectivity":13,"reading_time":1,"size":28.3,"color":"var(--graph-node-regular)","isCurrent":true},{"id":"2744152432949460445","label":"API Reference","url":"/docs/reference/api/","type":"regular","tags":["api","reference"],"incoming_refs":8,"outgoing_refs":5,"connectivity":13,"reading_time":5,"size":31.5,"color":"var(--graph-node-regular)","isCurrent":true},{"id":"-2680059364504895038","label":"Highlighting","url":"/docs/highlighting/","type":"regular","tags":["highlighting","api"],"incoming_refs":6,"outgoing_refs":5,"connectivity":11,"reading_time":1,"size":25.3,"color":"var(--graph-node-regular)","isCurrent":true},{"id":"-6014002478458981531","label":"Basic Usage","url":"/docs/highlighting/basic-usage/","type":"regular","tags":["highlighting","api"],"incoming_refs":4,"outgoing_refs":5,"connectivity":9,"reading_time":2,"size":23.1,"color":"var(--graph-node-regular)","isCurrent":true},{"id":"4241832673428245673","label":"Line Highlighting","url":"/docs/highlighting/line-highlighting/","type":"regular","tags":["highlighting","lines"],"incoming_refs":4,"outgoing_refs":3,"connectivity":7,"reading_time":2,"size":20.1,"color":"var(--graph-node-regular)","isCurrent":true},{"id":"-106756179683539329","label":"Parallel Processing","url":"/docs/highlighting/parallel/","type":"regular","tags":["parallel","performance"],"incoming_refs":4,"outgoing_refs":3,"connectivity":7,"reading_time":2,"size":20.1,"color":"var(--graph-node-regular)","isCurrent":true}],"edges":[{"source":"-2680059364504895038","target":"-6014002478458981531","weight":2},{"source":"-6014002478458981531","target":"2091112251267089877","weight":1},{"source":"-6014002478458981531","target":"4241832673428245673","weight":2},{"source":"-6014002478458981531","target":"2744152432949460445","weight":1},{"source":"-6014002478458981531","target":"-106756179683539329","weight":2}]}}