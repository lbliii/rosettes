{"url":"/docs/about/thread-safety/","title":"Thread Safety","description":"Thread-safe design and free-threading support","plain_text":"Thread Safety Rosettes is thread-safe by design, with explicit support for Python 3.14t's free-threading mode (PEP 703). Thread-Safe Guarantees All public APIs are safe for concurrent use: Component Thread Safety Mechanism highlight() Uses only local variables tokenize() Uses only local variables highlight_many() Thread pool with isolated workers Token Immutable NamedTuple get_lexer() functools.cache memoization How It Works 1. Immutable Tokens The Token type is a NamedTuple, which is immutable: class Token(NamedTuple): type: TokenType value: str line: int = 1 column: int = 1 Tokens cannot be modified after creation, eliminating data races. 2. Local-Only Lexer State Lexers use only local variables during tokenization: def tokenize(self, code: str) -&gt; Iterator[Token]: # All state is local state = State.INITIAL pos = 0 buffer = [] while pos &lt; len(code): # Process character ... No instance variables or global state are modified during tokenization. 3. Cached Registry The lexer registry uses functools.cache: @functools.cache def get_lexer(name: str) -&gt; Lexer: return LEXERS[name.lower()]() This provides thread-safe memoization—the same lexer instance is returned for the same name across all threads. 4. Immutable Configuration All configuration classes are frozen dataclasses: @dataclass(frozen=True) class FormatConfig: css_class: str = &quot;rosettes&quot; data_language: str = &quot;&quot; Free-Threading Support (PEP 703) Rosettes declares itself safe for free-threaded Python via the _Py_mod_gil attribute: def __getattr__(name: str) -&gt; object: if name == &quot;_Py_mod_gil&quot;: return 0 # Py_MOD_GIL_NOT_USED raise AttributeError(f&quot;module &#x27;rosettes&#x27; has no attribute {name!r}&quot;) This tells Python 3.14t that Rosettes: Does not require the GIL Can run with true parallelism Is safe for concurrent access without locks Concurrent Usage Patterns Safe: Multiple Threads Highlighting from concurrent.futures import ThreadPoolExecutor from rosettes import highlight def highlight_page(content: str) -&gt; str: # Extract and highlight all code blocks return highlight(content, &quot;python&quot;) with ThreadPoolExecutor(max_workers=4) as executor: pages = [&quot;code1&quot;, &quot;code2&quot;, &quot;code3&quot;, &quot;code4&quot;] results = list(executor.map(highlight_page, pages)) Safe: Shared Lexer Instance from rosettes import get_lexer # Same instance returned (cached) lexer = get_lexer(&quot;python&quot;) # Safe to use from multiple threads def process(code: str) -&gt; list: return list(lexer.tokenize(code)) Safe: highlight_many() from rosettes import highlight_many # Designed for parallel execution blocks = [(code, lang) for code, lang in code_blocks] results = highlight_many(blocks) # Thread pool internally What NOT to Do Don't: Modify Tokens # Tokens are immutable - this fails token = Token(TokenType.KEYWORD, &quot;def&quot;) token.value = &quot;class&quot; # ❌ AttributeError Don't: Rely on Global State # Don&#x27;t do this - Rosettes has no global mutable state import rosettes rosettes.SOME_SETTING = True # ❌ No effect, not supported Performance on 3.14t On Python 3.14t with free-threading enabled, highlight_many() provides true parallelism: Scenario GIL Python Free-Threading Speedup 10 blocks 15ms 12ms 1.25x 50 blocks 75ms 42ms 1.78x 100 blocks 150ms 78ms 1.92x The speedup comes from true parallel execution without GIL contention. Verifying Free-Threading Check if you're running free-threaded Python: import sys if hasattr(sys, &quot;_is_gil_enabled&quot;): if sys._is_gil_enabled(): print(&quot;GIL is enabled&quot;) else: print(&quot;Free-threading active!&quot;) else: print(&quot;Python &lt; 3.13 (always has GIL)&quot;) Next Steps Parallel Processing — Using highlight_many() Performance — Benchmarks and optimization","excerpt":"Thread Safety Rosettes is thread-safe by design, with explicit support for Python 3.14t's free-threading mode (PEP 703). Thread-Safe Guarantees All public APIs are safe for concurrent use: Component...","metadata":{"title":"Thread Safety","description":"Thread-safe design and free-threading support","draft":false,"weight":20,"lang":"en","type":"doc","tags":["threading","safety"],"keywords":["thread safety","free-threading","PEP 703","concurrent"],"icon":"shield","variant":"standard"},"section":"about","tags":["threading","safety"],"word_count":485,"reading_time":2,"graph":{"nodes":[{"id":"6906473773664142929","label":"About","url":"/docs/about/","type":"regular","tags":["about","architecture"],"incoming_refs":3,"outgoing_refs":5,"connectivity":8,"reading_time":1,"size":20.8,"color":"var(--graph-node-regular)","isCurrent":true},{"id":"3146124063214178861","label":"Performance","url":"/docs/about/performance/","type":"regular","tags":["performance","benchmarks"],"incoming_refs":4,"outgoing_refs":3,"connectivity":7,"reading_time":3,"size":20.9,"color":"var(--graph-node-regular)","isCurrent":true},{"id":"6850105790164573809","label":"Architecture","url":"/docs/about/architecture/","type":"regular","tags":["architecture","design"],"incoming_refs":3,"outgoing_refs":2,"connectivity":5,"reading_time":3,"size":17.9,"color":"var(--graph-node-regular)","isCurrent":true},{"id":"8660230327628514180","label":"Thread Safety","url":"/docs/about/thread-safety/","type":"regular","tags":["threading","safety"],"incoming_refs":3,"outgoing_refs":2,"connectivity":5,"reading_time":3,"size":17.9,"color":"var(--graph-node-regular)","isCurrent":true}],"edges":[{"source":"6906473773664142929","target":"8660230327628514180","weight":1},{"source":"6850105790164573809","target":"8660230327628514180","weight":2},{"source":"3146124063214178861","target":"8660230327628514180","weight":2}]}}